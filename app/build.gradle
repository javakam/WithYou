/**
 * gradle相关配置
 * https://github.com/javakam/ModuleApp/blob/c892a42bef2354068d6176a3a99f1723f5aca2ea/app/build.gradle
 */
apply plugin: 'com.android.application'
apply plugin: 'realm-android'

/*
Android Studio2.3.3到3.0版本后，同时也更新了gradle到4.1后,出现问题：
Error:android-apt plugin is incompatible with the Android Gradle plugin.
Please use 'annotationProcessor' configuration instead.
同时：apt dependencies["butterknife-compiler"]，apt改为 annotationProcessor*/

//apply plugin: 'android-apt'

//获取产品的名字
def getProductName() {
    return "WithYou"
}
//获取当前系统的时间
def releaseTime() {
    return new Date().format("yyyy-MM-dd_HH_mm_ss")
}

def config = rootProject.ext.android                    //配置
def library = rootProject.ext.dependencies              //依赖

android {
    compileSdkVersion config.compileSdkVersion
    buildToolsVersion config.buildToolsVersion
    defaultConfig {
        applicationId config.applicationId
        minSdkVersion config.minSdkVersion
        targetSdkVersion config.targetSdkVersion

        versionCode config.versionCode
        versionName config.versionName
        //当应用不需要支持几十种语言时，去除无用的语言资源
        /*
        注：resConfigs "hdpi", "xhdpi", "xxhdpi", "xxxhdpi"
        在新版本中已经废弃，替代方案是在 gradle 中使用 splits 根据不同的 ABI 以及不同的屏幕密度分别打包。 */
        resConfigs "zh", "en"
        multiDexEnabled true
        renderscriptTargetApi 23
        renderscriptSupportModeEnabled true
        /*
        manifestPlaceholders 用于替换变量
        https://blog.csdn.net/u011904605/article/details/54664831
        替换多个变量 manifestPlaceholders = [umeng_app_key: "你替代的内容",umeng_app_secret:"你要替换的内容"]*/
        manifestPlaceholders = [channel: "WithU"]

        /*
        没有的话会出现问题：
        Error:All flavors must now belong to a named flavor dimension.
        Learn more at https://d.android.com/r/tools/flavorDimensions-missing-error-message.html
        解决办法是加上   flavorDimensions "versionCode" versionCode就是你的版本号 */
        flavorDimensions String.valueOf(versionCode)

        javaCompileOptions {
            /*
            新版 gradle 插件不再支持 annotation processors，如果需要使用需要显式声明
            Error:java.lang.RuntimeException: Annotation processors must be explicitly declared now.
            The following dependencies on the compile classpath are found to contain annotation processor.
            Please add them to the annotationProcessor configuration.*/
            // 显式声明支持注解
            annotationProcessorOptions {
                includeCompileClasspath false
            }
        }
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"

        //打包时间
        resValue "string", "build_time", releaseTime()
    }

    //================================================分界线=================================================//

    //签名文件配置
    signingConfigs {
        sign_xiaomi {
            keyAlias 'xiaomi'
            keyPassword 'lovekam12'
//            storeFile file('E:\\2018-03\\lovesqsystem_keystore\\app_sq_key.jks')//签名文件路径
            storePassword 'lovekam12'
        }
    }
    // release版本中设置了开启混淆，并且定义了混淆文件的位置
    /* release和debug的差异主要在于是否可以在设备上调试应用以及APK如何签名。
    debug   版本会被使用已知的名称/密码自动生成的密钥/证书签名。
    release 版本在构建过程中不会被签名，需要构建后再签名。*/
    buildTypes {
        release {
            //更改AndroidManifest.xml中预先定义好占位符信息:
            /*
             In AndroidManifest.xml :
             <meta-data
                android:name="CHANNEL"
                android:value="${CHANNEL}" /> */
//            manifestPlaceholders = [app_icon: "@drawable/icon"]
            // 正式版不显示log
            buildConfigField "boolean", "LOG_DEBUG", "false"
            //是否zip对齐
            zipAlignEnabled true
            // 缩减resource文件，删除项目中没用到的资源文件
            // 当项目使用了很多第三方库的时候，这些库包含了很多资源文件，但是项目只使用了其中一小部分
            shrinkResources false
            //Proguard
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            //修改生成的apk名字，格式为 app名_版本号_打包时间_渠道名_release.apk
            applicationVariants.all { variant ->
                variant.outputs.all { output ->
                    def oldFile = output.outputFile
                    if (variant.buildType.name.equals('release')) {
                        outputFileName = getProductName() + "_v${variant.productFlavors[0].versionName}_${releaseTime()}_" + variant.productFlavors[0].name + '_release.apk'
                    }
                }
            }
            //签名
//            signingConfig signingConfigs.release
        }

        debug {
            // 正式版不显示log
            buildConfigField "boolean", "LOG_DEBUG", "true"
            shrinkResources false
            minifyEnabled false
        }
    }
    /*创建一个新的ProductFlavor的步骤为：
       在productFlavors容器下添加一个自定义名称的元素
       使用闭包进行配置*/
    productFlavors {
        xiaomi {
//            manifestPlaceholders = [CHANNEL: "xiaomi"]
            //buildConfigField -- TreeMap
            buildConfigField "String", "SERVER_URL", '"http://www.jooy.top/SQ/MobileProcess/"'
            buildConfigField "String", "CONFIG_FILE_NAME", '"SQ_Config.json"'
            buildConfigField "String", "APP_NAME", '"WithYou"'
            buildConfigField "boolean", "ISSERVICEDL", 'true'
            versionCode 1
            versionName "1.0"
            signingConfig signingConfigs.sign_xiaomi
        }
        huawei {
//            dimension "channle"
            minSdkVersion 21
            versionCode 1
//            versionName "1.0"
        }
    }

    productFlavors.all { flavor ->
        flavor.manifestPlaceholders = [CHANNEL: name]
    }

    //recommend
    dexOptions {
        jumboMode = true
        javaMaxHeapSize "4g"
        jumboMode true
    }

    //指定java版本，支持lambda表达式
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    //排除不想添加到apk中的文件
    packagingOptions {
        exclude('META-INF/rxjava.properties')
        exclude 'META-INF/DEPENDENCIES.txt'
        exclude 'META-INF/LICENSE.txt'
        exclude 'META-INF/NOTICE.txt'
        exclude 'META-INF/NOTICE'
        exclude 'META-INF/LICENSE'
        exclude 'META-INF/DEPENDENCIES'
        exclude 'META-INF/notice.txt'
        exclude 'META-INF/license.txt'
        exclude 'META-INF/dependencies.txt'
        exclude 'META-INF/LGPL2.1'
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'

    /*
    注意，组件化在library中引入butterknife后，dependencies里library和app都要引入依赖才能生效，否则空指针
    还有，library中使用R2.id.xxx ； app中 R.id.xxx
    总之一句话，那个module/app需要用butterknife就在相应的build.gradle中引入如下两句代码
     */
    implementation library["butterknife"]
    annotationProcessor library["butterknife-compiler"]

    api project(':module_wandroid')
}
